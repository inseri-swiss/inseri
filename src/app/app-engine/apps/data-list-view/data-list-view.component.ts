import {Component, Input, Output, OnInit, OnChanges, EventEmitter} from '@angular/core';
import { DataListViewInAppQueryService } from './services/query.service';
import { DisplayedCollumnsService } from './data-list-view-services/table-data.service';
// import { DataListViewSettings } from './data-list-view-settings/data-list-view-settings.service';
import fallbackSettings from './assets/settings.json';

@Component({
  selector: 'data-list-view',
  templateUrl: './data-list-view.component.html'
})

export class DataListViewComponent implements OnChanges {
  @Input() queryResponse?: Array<any>;
  @Input() dataListSettings?: any; // DataListViewSettings;
  @Input() query?: string;
  @Output() displayedColumns: Array<string> = [];
  @Output() dataListSettingsOut: any;
  @Output() resData: any;
  tableData: Array<any> = [];

  constructor(private dataService: DataListViewInAppQueryService,
              private displayedCollumnsService: DisplayedCollumnsService,
              // private settingsService: DataListViewSettings
  ) {
  }

  ngOnChanges() {
    this.getSettings();
    this.onGetData();
  }

  generateTableData(responseData: any, depth: number) {
    if (this.dataListSettingsOut.columns.genericColumns) {
      let length = 0;
      for (const entry of responseData.results.bindings) {
        this.flattenObjects(entry, length);
        length += 1;
      } this.resData = this.tableData;
    } else {
      let length = -1;
      for (const responseEntry of responseData) {
        length += 1;
        this.appendEntryToTabledata(responseEntry, 0, length);
      }
    }
  }

  appendEntryToTabledata(ResponseEntry: any, depth: number, length: number, pathCompare?: Array<string>) {
    // recursive method for getting the actual values from nested jsons
    // and appending them to the tabledata. Allowed values are strings,
    // numbers, symbols and booleans (so no objects allowed here).
    for (const column of this.dataListSettingsOut.columns.columnMapping) {
      if (typeof ResponseEntry[column.path[depth]] === 'string' ||
        typeof ResponseEntry[column.path[depth]] === 'number' ||
        typeof ResponseEntry[column.path[depth]] === 'symbol' ||
        typeof ResponseEntry[column.path[depth]] === 'boolean') {
        // checks if the path of a recursive function call is the same as the column
        // generated by the for loop, this is necessary if more than one column has in the same depths the same segment names
        if (pathCompare === undefined || pathCompare === column.path) {
          this.append(ResponseEntry[column.path[depth]], column.name, length);
        }
      } else if (typeof ResponseEntry[column.path[depth]] === 'object') {
        this.appendEntryToTabledata(ResponseEntry[column.path[depth]], depth + 1, length, column.path);
      }
    }
  }

  append(entry: string, name: string, length: number) {
    // is appending the collected values to the tabledata
    if (this.tableData[length] === undefined) {
      this.tableData[length] = {};
    }
    this.tableData[length][name] = entry;
    if (this.tableData.length === this.queryResponse.length) {
      this.resData = this.tableData;
    }
  }


  flattenObjects(input, length, reference?, output?) {
    // FLATTENS the response completely and assigns the result to tableData.
    output = output || {};
    for (let key of Object.keys(input)) {
      const value = input[key];
      if (reference) {
        key = reference + '.' + key;
      }
      if (typeof value === 'object' && value !== null) {
        this.flattenObjects(value, length, key, output);
      } else {
        output[key] = value;
        // renesting with name and types
        // output[key]['value'] = value;
        // if (reference['type'] || reference['whatever']) {
        //  output[key]['type'] = reference['type'];
        // }

      }
    }
    this.tableData[length] = output;
  }


  // GET the data - either by a passed input from another app/service or by a passed query
  private onGetData() {
    if ( this.dataListSettingsOut.inputMode === 'query' ) {
      this.getTableDataFromQuery(this.query);
      } else if ( this.dataListSettingsOut.inputMode === 'input') {
          if (this.queryResponse ) {
            console.log( this.dataListSettings );
            this.displayedColumns = this.displayedCollumnsService.getDisplayedColumns(this.dataListSettings, this.queryResponse);
            this.generateTableData(this.queryResponse, 0);
        } else { console.log('No queryResponse passed by input as defined in dataListSettingsOut.inputMode: ' + this.dataListSettingsOut.inputMode); }
      } else { console.log('Wrong dataListSettings definition for --> \"inputmode: ' + this.dataListSettingsOut.inputMode + '\" allowed are: input, query'); }
    }

  private getTableDataFromQuery(query) {
    this.dataService.getData( this.query ).subscribe(data => {
      const responseData: any = data;
      this.queryResponse = responseData.results.bindings;
      this.generateTableData(this.queryResponse, 0);
      this.displayedColumns = this.displayedCollumnsService.getDisplayedColumns(this.dataListSettingsOut, this.queryResponse);

    });
  }

  private getSettings() {
      if ( this.dataListSettings ) {
        this.dataListSettingsOut = this.dataListSettings;
        console.log('Got dataListSettings by input: ', this.dataListSettingsOut);
      } else {

        console.log('No dataListSettings input. Loading fallback dataListSettings.');
        this.dataListSettingsOut = fallbackSettings; // this.settingsService.generateDataListViewSettings(this.dataListSettings);
      }
    }
}
