import { Component, Input, Output, OnInit, OnChanges } from '@angular/core';
import { QueryService } from './services/query.service';
import { DisplayedCollumnsService } from './data-list-view-services/table-data.service';
// import { DataListViewSettings } from './data-list-view-settings/data-list-view-settings.service';

@Component({
  selector: 'app-data-list-view',
  templateUrl: './data-list-view.component.html'
})

export class DataListViewComponent implements OnChanges {
  @Input() dataToDisplay?: Array<any>;
  @Input() settings?: any; // DataListViewSettings;
  @Input() query?: string;
  @Output() displayedColumns: Array<string> = [];
  @Output() dataListSettings: any;
  @Output() resData: any;
  tableData: Array<any> = [];

  constructor(private dataService: QueryService,
              private displayedCollumnsService: DisplayedCollumnsService,
              // private datalistViewSettings: DataListViewSettings
  ) {
  }

  ngOnChanges() {
    this.getSettings();
    this.onGetData();
  }

  generateTableData(responseData: Array<any>, depth: number) {
    if (this.dataListSettings.columns.genericColumns) {
      let length = 0;
      for (const entry of responseData) {
        this.flattenObjects(entry, length);
        length += 1;
      }
      this.resData = this.tableData;
      // console.log(this.resData);
    } else {
      let length = -1;
      for (const responseEntry of responseData) {
        length += 1;
        this.appendEntryToTabledata(responseEntry, 0, length);
      }
    }
  }

  appendEntryToTabledata(ResponseEntry: any, depth: number, length: number, pathCompare?: Array<string>) {
    // recursive method for getting the actual values from nested jsons
    // and appending them to the tabledata. Allowed values are strings,
    // numbers, symbols and booleans (so no objects allowed here).
    for (const column of this.dataListSettings.columns.columnMapping) {
      if (typeof ResponseEntry[column.path[depth]] === 'string' ||
        typeof ResponseEntry[column.path[depth]] === 'number' ||
        typeof ResponseEntry[column.path[depth]] === 'symbol' ||
        typeof ResponseEntry[column.path[depth]] === 'boolean') {
        // checks if the path of a recursive function call is the same as the column
        // generated by the for loop, this is necessary if more than one column has in the same depths the same segment names
        if (pathCompare === undefined || pathCompare === column.path) {
          this.append(ResponseEntry[column.path[depth]], column.name, length);
        }
      } else if (typeof ResponseEntry[column.path[depth]] === 'object') {
        this.appendEntryToTabledata(ResponseEntry[column.path[depth]], depth + 1, length, column.path);
      }
    }
  }

  append(entry: string, name: string, length: number) {
    // is appending the collected values to the tabledata
    if (this.tableData[length] === undefined) {
      this.tableData[length] = {};
    }
    this.tableData[length][name] = entry;
    if (this.tableData.length === this.dataToDisplay.length) {
      this.resData = this.tableData;
    }
  }


  flattenObjects(input, length, reference?, output?) {
    // FLATTENS the response completely and assigns the result to tableData.
    output = output || {};
    for (let key of Object.keys(input)) {
      const value = input[key];
      if (reference) {
        key = reference + '.' + key;
      }
      if (typeof value === 'object' && value !== null) {
        this.flattenObjects(value, length, key, output);
      } else {
        output[key] = value;
        // renesting with name and types
        // output[key]['value'] = value;
        // if (reference['type'] || reference['whatever']) {
        //  output[key]['type'] = reference['type'];
        // }

      }
    }
    this.tableData[length] = output;
  }


  // GET the data - either by a passed input from another app/service or by a passed query
  private onGetData() {
    if ( this.dataListSettings.inputMode === 'query' ) {
      console.log('getting data by running a SPARQL query.');
      console.log('this.dataListSettings): ' + this.dataListSettings) ;
      this.getTableDataFromQuery(this.query);
      } else if ( this.dataListSettings.inputMode === 'input') {
          console.log('getting data by input.');
          if (this.dataToDisplay ) {
            this.generateTableData(this.dataToDisplay, 0);
            // this.displayedColumns = this.displayedCollumnsService.getDisplayedColumns(this.dataListSettings, this.dataToDisplay);
        } else { console.log('No dataToDisplay passed by input as defined in dataListSettings.inputMode: ' + this.dataListSettings.inputMode); }
      } else { console.log('Wrong settings definition for --> \"inputmode: ' + this.dataListSettings.inputMode + '\" allowed are: input, query'); }
    }

  private getTableDataFromQuery(query) {
    this.dataService.getData( this.query ).subscribe(data => {
      const responseData: any = data;
      this.dataToDisplay = responseData.results.bindings;
      this.generateTableData(this.dataToDisplay, 0);
      this.displayedColumns = this.displayedCollumnsService.getDisplayedColumns(this.dataListSettings, this.dataToDisplay);
    });
  }

  private getSettings() {
      if ( this.settings ) {
        this.dataListSettings = this.settings;
        console.log('Got settings by input: ', this.dataListSettings);
      } else {
        console.log('No settings input. Loading fallback settings.');
        // this.dataListSettings = this.datalistViewSettings.generateDataListViewSettings();
      }
    }
}
